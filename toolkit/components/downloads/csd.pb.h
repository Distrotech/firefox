// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csd.proto

#ifndef PROTOBUF_csd_2eproto__INCLUDED
#define PROTOBUF_csd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace safe_browsing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_csd_2eproto();
void protobuf_AssignDesc_csd_2eproto();
void protobuf_ShutdownFile_csd_2eproto();

class ClientPhishingRequest;
class ClientPhishingRequest_Feature;
class ClientPhishingResponse;
class ClientMalwareRequest;
class ClientMalwareRequest_Feature;
class ClientMalwareResponse;
class ClientDownloadRequest;
class ClientDownloadRequest_Digests;
class ClientDownloadRequest_Resource;
class ClientDownloadRequest_CertificateChain;
class ClientDownloadRequest_CertificateChain_Element;
class ClientDownloadRequest_SignatureInfo;
class ClientDownloadResponse;
class ClientDownloadResponse_MoreInfo;
class ClientDownloadReport;
class ClientDownloadReport_UserInformation;
class ClientUploadResponse;

enum ClientDownloadRequest_ResourceType {
  ClientDownloadRequest_ResourceType_DOWNLOAD_URL = 0,
  ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT = 1,
  ClientDownloadRequest_ResourceType_TAB_URL = 2,
  ClientDownloadRequest_ResourceType_TAB_REDIRECT = 3
};
bool ClientDownloadRequest_ResourceType_IsValid(int value);
const ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MIN = ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
const ClientDownloadRequest_ResourceType ClientDownloadRequest_ResourceType_ResourceType_MAX = ClientDownloadRequest_ResourceType_TAB_REDIRECT;
const int ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE = ClientDownloadRequest_ResourceType_ResourceType_MAX + 1;

enum ClientDownloadRequest_DownloadType {
  ClientDownloadRequest_DownloadType_WIN_EXECUTABLE = 0,
  ClientDownloadRequest_DownloadType_CHROME_EXTENSION = 1,
  ClientDownloadRequest_DownloadType_ANDROID_APK = 2,
  ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE = 3
};
bool ClientDownloadRequest_DownloadType_IsValid(int value);
const ClientDownloadRequest_DownloadType ClientDownloadRequest_DownloadType_DownloadType_MIN = ClientDownloadRequest_DownloadType_WIN_EXECUTABLE;
const ClientDownloadRequest_DownloadType ClientDownloadRequest_DownloadType_DownloadType_MAX = ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE;
const int ClientDownloadRequest_DownloadType_DownloadType_ARRAYSIZE = ClientDownloadRequest_DownloadType_DownloadType_MAX + 1;

enum ClientDownloadResponse_Verdict {
  ClientDownloadResponse_Verdict_SAFE = 0,
  ClientDownloadResponse_Verdict_DANGEROUS = 1,
  ClientDownloadResponse_Verdict_UNCOMMON = 2,
  ClientDownloadResponse_Verdict_POTENTIALLY_UNWANTED = 3,
  ClientDownloadResponse_Verdict_DANGEROUS_HOST = 4
};
bool ClientDownloadResponse_Verdict_IsValid(int value);
const ClientDownloadResponse_Verdict ClientDownloadResponse_Verdict_Verdict_MIN = ClientDownloadResponse_Verdict_SAFE;
const ClientDownloadResponse_Verdict ClientDownloadResponse_Verdict_Verdict_MAX = ClientDownloadResponse_Verdict_DANGEROUS_HOST;
const int ClientDownloadResponse_Verdict_Verdict_ARRAYSIZE = ClientDownloadResponse_Verdict_Verdict_MAX + 1;

enum ClientDownloadReport_Reason {
  ClientDownloadReport_Reason_SHARE = 0,
  ClientDownloadReport_Reason_FALSE_POSITIVE = 1,
  ClientDownloadReport_Reason_APPEAL = 2
};
bool ClientDownloadReport_Reason_IsValid(int value);
const ClientDownloadReport_Reason ClientDownloadReport_Reason_Reason_MIN = ClientDownloadReport_Reason_SHARE;
const ClientDownloadReport_Reason ClientDownloadReport_Reason_Reason_MAX = ClientDownloadReport_Reason_APPEAL;
const int ClientDownloadReport_Reason_Reason_ARRAYSIZE = ClientDownloadReport_Reason_Reason_MAX + 1;

enum ClientUploadResponse_UploadStatus {
  ClientUploadResponse_UploadStatus_SUCCESS = 0,
  ClientUploadResponse_UploadStatus_UPLOAD_FAILURE = 1
};
bool ClientUploadResponse_UploadStatus_IsValid(int value);
const ClientUploadResponse_UploadStatus ClientUploadResponse_UploadStatus_UploadStatus_MIN = ClientUploadResponse_UploadStatus_SUCCESS;
const ClientUploadResponse_UploadStatus ClientUploadResponse_UploadStatus_UploadStatus_MAX = ClientUploadResponse_UploadStatus_UPLOAD_FAILURE;
const int ClientUploadResponse_UploadStatus_UploadStatus_ARRAYSIZE = ClientUploadResponse_UploadStatus_UploadStatus_MAX + 1;

// ===================================================================

class ClientPhishingRequest_Feature : public ::google::protobuf::MessageLite {
 public:
  ClientPhishingRequest_Feature();
  virtual ~ClientPhishingRequest_Feature();
  
  ClientPhishingRequest_Feature(const ClientPhishingRequest_Feature& from);
  
  inline ClientPhishingRequest_Feature& operator=(const ClientPhishingRequest_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientPhishingRequest_Feature& default_instance();
  
  void Swap(ClientPhishingRequest_Feature* other);
  
  // implements Message ----------------------------------------------
  
  ClientPhishingRequest_Feature* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientPhishingRequest_Feature& from);
  void MergeFrom(const ClientPhishingRequest_Feature& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientPhishingRequest.Feature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::std::string* name_;
  double value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientPhishingRequest_Feature* default_instance_;
};
// -------------------------------------------------------------------

class ClientPhishingRequest : public ::google::protobuf::MessageLite {
 public:
  ClientPhishingRequest();
  virtual ~ClientPhishingRequest();
  
  ClientPhishingRequest(const ClientPhishingRequest& from);
  
  inline ClientPhishingRequest& operator=(const ClientPhishingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientPhishingRequest& default_instance();
  
  void Swap(ClientPhishingRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientPhishingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientPhishingRequest& from);
  void MergeFrom(const ClientPhishingRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientPhishingRequest_Feature Feature;
  
  // accessors -------------------------------------------------------
  
  // optional string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional bytes OBSOLETE_hash_prefix = 10;
  inline bool has_obsolete_hash_prefix() const;
  inline void clear_obsolete_hash_prefix();
  static const int kOBSOLETEHashPrefixFieldNumber = 10;
  inline const ::std::string& obsolete_hash_prefix() const;
  inline void set_obsolete_hash_prefix(const ::std::string& value);
  inline void set_obsolete_hash_prefix(const char* value);
  inline void set_obsolete_hash_prefix(const void* value, size_t size);
  inline ::std::string* mutable_obsolete_hash_prefix();
  inline ::std::string* release_obsolete_hash_prefix();
  
  // required float client_score = 2;
  inline bool has_client_score() const;
  inline void clear_client_score();
  static const int kClientScoreFieldNumber = 2;
  inline float client_score() const;
  inline void set_client_score(float value);
  
  // optional bool is_phishing = 4;
  inline bool has_is_phishing() const;
  inline void clear_is_phishing();
  static const int kIsPhishingFieldNumber = 4;
  inline bool is_phishing() const;
  inline void set_is_phishing(bool value);
  
  // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
  inline int feature_map_size() const;
  inline void clear_feature_map();
  static const int kFeatureMapFieldNumber = 5;
  inline const ::safe_browsing::ClientPhishingRequest_Feature& feature_map(int index) const;
  inline ::safe_browsing::ClientPhishingRequest_Feature* mutable_feature_map(int index);
  inline ::safe_browsing::ClientPhishingRequest_Feature* add_feature_map();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >&
      feature_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >*
      mutable_feature_map();
  
  // optional int32 model_version = 6;
  inline bool has_model_version() const;
  inline void clear_model_version();
  static const int kModelVersionFieldNumber = 6;
  inline ::google::protobuf::int32 model_version() const;
  inline void set_model_version(::google::protobuf::int32 value);
  
  // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
  inline int non_model_feature_map_size() const;
  inline void clear_non_model_feature_map();
  static const int kNonModelFeatureMapFieldNumber = 8;
  inline const ::safe_browsing::ClientPhishingRequest_Feature& non_model_feature_map(int index) const;
  inline ::safe_browsing::ClientPhishingRequest_Feature* mutable_non_model_feature_map(int index);
  inline ::safe_browsing::ClientPhishingRequest_Feature* add_non_model_feature_map();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >&
      non_model_feature_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >*
      mutable_non_model_feature_map();
  
  // optional string OBSOLETE_referrer_url = 9;
  inline bool has_obsolete_referrer_url() const;
  inline void clear_obsolete_referrer_url();
  static const int kOBSOLETEReferrerUrlFieldNumber = 9;
  inline const ::std::string& obsolete_referrer_url() const;
  inline void set_obsolete_referrer_url(const ::std::string& value);
  inline void set_obsolete_referrer_url(const char* value);
  inline void set_obsolete_referrer_url(const char* value, size_t size);
  inline ::std::string* mutable_obsolete_referrer_url();
  inline ::std::string* release_obsolete_referrer_url();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientPhishingRequest)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_obsolete_hash_prefix();
  inline void clear_has_obsolete_hash_prefix();
  inline void set_has_client_score();
  inline void clear_has_client_score();
  inline void set_has_is_phishing();
  inline void clear_has_is_phishing();
  inline void set_has_model_version();
  inline void clear_has_model_version();
  inline void set_has_obsolete_referrer_url();
  inline void clear_has_obsolete_referrer_url();
  
  ::std::string* url_;
  ::std::string* obsolete_hash_prefix_;
  float client_score_;
  bool is_phishing_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature > feature_map_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature > non_model_feature_map_;
  ::std::string* obsolete_referrer_url_;
  ::google::protobuf::int32 model_version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientPhishingRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientPhishingResponse : public ::google::protobuf::MessageLite {
 public:
  ClientPhishingResponse();
  virtual ~ClientPhishingResponse();
  
  ClientPhishingResponse(const ClientPhishingResponse& from);
  
  inline ClientPhishingResponse& operator=(const ClientPhishingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientPhishingResponse& default_instance();
  
  void Swap(ClientPhishingResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientPhishingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientPhishingResponse& from);
  void MergeFrom(const ClientPhishingResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool phishy = 1;
  inline bool has_phishy() const;
  inline void clear_phishy();
  static const int kPhishyFieldNumber = 1;
  inline bool phishy() const;
  inline void set_phishy(bool value);
  
  // repeated string OBSOLETE_whitelist_expression = 2;
  inline int obsolete_whitelist_expression_size() const;
  inline void clear_obsolete_whitelist_expression();
  static const int kOBSOLETEWhitelistExpressionFieldNumber = 2;
  inline const ::std::string& obsolete_whitelist_expression(int index) const;
  inline ::std::string* mutable_obsolete_whitelist_expression(int index);
  inline void set_obsolete_whitelist_expression(int index, const ::std::string& value);
  inline void set_obsolete_whitelist_expression(int index, const char* value);
  inline void set_obsolete_whitelist_expression(int index, const char* value, size_t size);
  inline ::std::string* add_obsolete_whitelist_expression();
  inline void add_obsolete_whitelist_expression(const ::std::string& value);
  inline void add_obsolete_whitelist_expression(const char* value);
  inline void add_obsolete_whitelist_expression(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& obsolete_whitelist_expression() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_obsolete_whitelist_expression();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientPhishingResponse)
 private:
  inline void set_has_phishy();
  inline void clear_has_phishy();
  
  ::google::protobuf::RepeatedPtrField< ::std::string> obsolete_whitelist_expression_;
  bool phishy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientPhishingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientMalwareRequest_Feature : public ::google::protobuf::MessageLite {
 public:
  ClientMalwareRequest_Feature();
  virtual ~ClientMalwareRequest_Feature();
  
  ClientMalwareRequest_Feature(const ClientMalwareRequest_Feature& from);
  
  inline ClientMalwareRequest_Feature& operator=(const ClientMalwareRequest_Feature& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientMalwareRequest_Feature& default_instance();
  
  void Swap(ClientMalwareRequest_Feature* other);
  
  // implements Message ----------------------------------------------
  
  ClientMalwareRequest_Feature* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMalwareRequest_Feature& from);
  void MergeFrom(const ClientMalwareRequest_Feature& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);
  
  // repeated string metainfo = 3;
  inline int metainfo_size() const;
  inline void clear_metainfo();
  static const int kMetainfoFieldNumber = 3;
  inline const ::std::string& metainfo(int index) const;
  inline ::std::string* mutable_metainfo(int index);
  inline void set_metainfo(int index, const ::std::string& value);
  inline void set_metainfo(int index, const char* value);
  inline void set_metainfo(int index, const char* value, size_t size);
  inline ::std::string* add_metainfo();
  inline void add_metainfo(const ::std::string& value);
  inline void add_metainfo(const char* value);
  inline void add_metainfo(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& metainfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_metainfo();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientMalwareRequest.Feature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::std::string* name_;
  double value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> metainfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientMalwareRequest_Feature* default_instance_;
};
// -------------------------------------------------------------------

class ClientMalwareRequest : public ::google::protobuf::MessageLite {
 public:
  ClientMalwareRequest();
  virtual ~ClientMalwareRequest();
  
  ClientMalwareRequest(const ClientMalwareRequest& from);
  
  inline ClientMalwareRequest& operator=(const ClientMalwareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientMalwareRequest& default_instance();
  
  void Swap(ClientMalwareRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientMalwareRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMalwareRequest& from);
  void MergeFrom(const ClientMalwareRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientMalwareRequest_Feature Feature;
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // repeated .safe_browsing.ClientMalwareRequest.Feature feature_map = 2;
  inline int feature_map_size() const;
  inline void clear_feature_map();
  static const int kFeatureMapFieldNumber = 2;
  inline const ::safe_browsing::ClientMalwareRequest_Feature& feature_map(int index) const;
  inline ::safe_browsing::ClientMalwareRequest_Feature* mutable_feature_map(int index);
  inline ::safe_browsing::ClientMalwareRequest_Feature* add_feature_map();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientMalwareRequest_Feature >&
      feature_map() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientMalwareRequest_Feature >*
      mutable_feature_map();
  
  // optional string referrer_url = 4;
  inline bool has_referrer_url() const;
  inline void clear_referrer_url();
  static const int kReferrerUrlFieldNumber = 4;
  inline const ::std::string& referrer_url() const;
  inline void set_referrer_url(const ::std::string& value);
  inline void set_referrer_url(const char* value);
  inline void set_referrer_url(const char* value, size_t size);
  inline ::std::string* mutable_referrer_url();
  inline ::std::string* release_referrer_url();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientMalwareRequest)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_referrer_url();
  inline void clear_has_referrer_url();
  
  ::std::string* url_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientMalwareRequest_Feature > feature_map_;
  ::std::string* referrer_url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientMalwareRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientMalwareResponse : public ::google::protobuf::MessageLite {
 public:
  ClientMalwareResponse();
  virtual ~ClientMalwareResponse();
  
  ClientMalwareResponse(const ClientMalwareResponse& from);
  
  inline ClientMalwareResponse& operator=(const ClientMalwareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientMalwareResponse& default_instance();
  
  void Swap(ClientMalwareResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientMalwareResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientMalwareResponse& from);
  void MergeFrom(const ClientMalwareResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool blacklist = 1;
  inline bool has_blacklist() const;
  inline void clear_blacklist();
  static const int kBlacklistFieldNumber = 1;
  inline bool blacklist() const;
  inline void set_blacklist(bool value);
  
  // optional string bad_ip = 2;
  inline bool has_bad_ip() const;
  inline void clear_bad_ip();
  static const int kBadIpFieldNumber = 2;
  inline const ::std::string& bad_ip() const;
  inline void set_bad_ip(const ::std::string& value);
  inline void set_bad_ip(const char* value);
  inline void set_bad_ip(const char* value, size_t size);
  inline ::std::string* mutable_bad_ip();
  inline ::std::string* release_bad_ip();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientMalwareResponse)
 private:
  inline void set_has_blacklist();
  inline void clear_has_blacklist();
  inline void set_has_bad_ip();
  inline void clear_has_bad_ip();
  
  ::std::string* bad_ip_;
  bool blacklist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientMalwareResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_Digests : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_Digests();
  virtual ~ClientDownloadRequest_Digests();
  
  ClientDownloadRequest_Digests(const ClientDownloadRequest_Digests& from);
  
  inline ClientDownloadRequest_Digests& operator=(const ClientDownloadRequest_Digests& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_Digests& default_instance();
  
  void Swap(ClientDownloadRequest_Digests* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_Digests* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_Digests& from);
  void MergeFrom(const ClientDownloadRequest_Digests& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes sha256 = 1;
  inline bool has_sha256() const;
  inline void clear_sha256();
  static const int kSha256FieldNumber = 1;
  inline const ::std::string& sha256() const;
  inline void set_sha256(const ::std::string& value);
  inline void set_sha256(const char* value);
  inline void set_sha256(const void* value, size_t size);
  inline ::std::string* mutable_sha256();
  inline ::std::string* release_sha256();
  
  // optional bytes sha1 = 2;
  inline bool has_sha1() const;
  inline void clear_sha1();
  static const int kSha1FieldNumber = 2;
  inline const ::std::string& sha1() const;
  inline void set_sha1(const ::std::string& value);
  inline void set_sha1(const char* value);
  inline void set_sha1(const void* value, size_t size);
  inline ::std::string* mutable_sha1();
  inline ::std::string* release_sha1();
  
  // optional bytes md5 = 3;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 3;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const void* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.Digests)
 private:
  inline void set_has_sha256();
  inline void clear_has_sha256();
  inline void set_has_sha1();
  inline void clear_has_sha1();
  inline void set_has_md5();
  inline void clear_has_md5();
  
  ::std::string* sha256_;
  ::std::string* sha1_;
  ::std::string* md5_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_Digests* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_Resource : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_Resource();
  virtual ~ClientDownloadRequest_Resource();
  
  ClientDownloadRequest_Resource(const ClientDownloadRequest_Resource& from);
  
  inline ClientDownloadRequest_Resource& operator=(const ClientDownloadRequest_Resource& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_Resource& default_instance();
  
  void Swap(ClientDownloadRequest_Resource* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_Resource* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_Resource& from);
  void MergeFrom(const ClientDownloadRequest_Resource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::safe_browsing::ClientDownloadRequest_ResourceType type() const;
  inline void set_type(::safe_browsing::ClientDownloadRequest_ResourceType value);
  
  // optional bytes remote_ip = 3;
  inline bool has_remote_ip() const;
  inline void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 3;
  inline const ::std::string& remote_ip() const;
  inline void set_remote_ip(const ::std::string& value);
  inline void set_remote_ip(const char* value);
  inline void set_remote_ip(const void* value, size_t size);
  inline ::std::string* mutable_remote_ip();
  inline ::std::string* release_remote_ip();
  
  // optional string referrer = 4;
  inline bool has_referrer() const;
  inline void clear_referrer();
  static const int kReferrerFieldNumber = 4;
  inline const ::std::string& referrer() const;
  inline void set_referrer(const ::std::string& value);
  inline void set_referrer(const char* value);
  inline void set_referrer(const char* value, size_t size);
  inline ::std::string* mutable_referrer();
  inline ::std::string* release_referrer();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.Resource)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_remote_ip();
  inline void clear_has_remote_ip();
  inline void set_has_referrer();
  inline void clear_has_referrer();
  
  ::std::string* url_;
  ::std::string* remote_ip_;
  ::std::string* referrer_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_Resource* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_CertificateChain_Element : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_CertificateChain_Element();
  virtual ~ClientDownloadRequest_CertificateChain_Element();
  
  ClientDownloadRequest_CertificateChain_Element(const ClientDownloadRequest_CertificateChain_Element& from);
  
  inline ClientDownloadRequest_CertificateChain_Element& operator=(const ClientDownloadRequest_CertificateChain_Element& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_CertificateChain_Element& default_instance();
  
  void Swap(ClientDownloadRequest_CertificateChain_Element* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_CertificateChain_Element* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_CertificateChain_Element& from);
  void MergeFrom(const ClientDownloadRequest_CertificateChain_Element& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes certificate = 1;
  inline bool has_certificate() const;
  inline void clear_certificate();
  static const int kCertificateFieldNumber = 1;
  inline const ::std::string& certificate() const;
  inline void set_certificate(const ::std::string& value);
  inline void set_certificate(const char* value);
  inline void set_certificate(const void* value, size_t size);
  inline ::std::string* mutable_certificate();
  inline ::std::string* release_certificate();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
 private:
  inline void set_has_certificate();
  inline void clear_has_certificate();
  
  ::std::string* certificate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_CertificateChain_Element* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_CertificateChain : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_CertificateChain();
  virtual ~ClientDownloadRequest_CertificateChain();
  
  ClientDownloadRequest_CertificateChain(const ClientDownloadRequest_CertificateChain& from);
  
  inline ClientDownloadRequest_CertificateChain& operator=(const ClientDownloadRequest_CertificateChain& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_CertificateChain& default_instance();
  
  void Swap(ClientDownloadRequest_CertificateChain* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_CertificateChain* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_CertificateChain& from);
  void MergeFrom(const ClientDownloadRequest_CertificateChain& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadRequest_CertificateChain_Element Element;
  
  // accessors -------------------------------------------------------
  
  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
  inline int element_size() const;
  inline void clear_element();
  static const int kElementFieldNumber = 1;
  inline const ::safe_browsing::ClientDownloadRequest_CertificateChain_Element& element(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* mutable_element(int index);
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* add_element();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >&
      element() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >*
      mutable_element();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.CertificateChain)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element > element_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_CertificateChain* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest_SignatureInfo : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest_SignatureInfo();
  virtual ~ClientDownloadRequest_SignatureInfo();
  
  ClientDownloadRequest_SignatureInfo(const ClientDownloadRequest_SignatureInfo& from);
  
  inline ClientDownloadRequest_SignatureInfo& operator=(const ClientDownloadRequest_SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest_SignatureInfo& default_instance();
  
  void Swap(ClientDownloadRequest_SignatureInfo* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest_SignatureInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest_SignatureInfo& from);
  void MergeFrom(const ClientDownloadRequest_SignatureInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
  inline int certificate_chain_size() const;
  inline void clear_certificate_chain();
  static const int kCertificateChainFieldNumber = 1;
  inline const ::safe_browsing::ClientDownloadRequest_CertificateChain& certificate_chain(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain* mutable_certificate_chain(int index);
  inline ::safe_browsing::ClientDownloadRequest_CertificateChain* add_certificate_chain();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >&
      certificate_chain() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >*
      mutable_certificate_chain();
  
  // optional bool trusted = 2;
  inline bool has_trusted() const;
  inline void clear_trusted();
  static const int kTrustedFieldNumber = 2;
  inline bool trusted() const;
  inline void set_trusted(bool value);
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest.SignatureInfo)
 private:
  inline void set_has_trusted();
  inline void clear_has_trusted();
  
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain > certificate_chain_;
  bool trusted_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest_SignatureInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadRequest : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadRequest();
  virtual ~ClientDownloadRequest();
  
  ClientDownloadRequest(const ClientDownloadRequest& from);
  
  inline ClientDownloadRequest& operator=(const ClientDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadRequest& default_instance();
  
  void Swap(ClientDownloadRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadRequest& from);
  void MergeFrom(const ClientDownloadRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadRequest_Digests Digests;
  typedef ClientDownloadRequest_Resource Resource;
  typedef ClientDownloadRequest_CertificateChain CertificateChain;
  typedef ClientDownloadRequest_SignatureInfo SignatureInfo;
  
  typedef ClientDownloadRequest_ResourceType ResourceType;
  static const ResourceType DOWNLOAD_URL = ClientDownloadRequest_ResourceType_DOWNLOAD_URL;
  static const ResourceType DOWNLOAD_REDIRECT = ClientDownloadRequest_ResourceType_DOWNLOAD_REDIRECT;
  static const ResourceType TAB_URL = ClientDownloadRequest_ResourceType_TAB_URL;
  static const ResourceType TAB_REDIRECT = ClientDownloadRequest_ResourceType_TAB_REDIRECT;
  static inline bool ResourceType_IsValid(int value) {
    return ClientDownloadRequest_ResourceType_IsValid(value);
  }
  static const ResourceType ResourceType_MIN =
    ClientDownloadRequest_ResourceType_ResourceType_MIN;
  static const ResourceType ResourceType_MAX =
    ClientDownloadRequest_ResourceType_ResourceType_MAX;
  static const int ResourceType_ARRAYSIZE =
    ClientDownloadRequest_ResourceType_ResourceType_ARRAYSIZE;
  
  typedef ClientDownloadRequest_DownloadType DownloadType;
  static const DownloadType WIN_EXECUTABLE = ClientDownloadRequest_DownloadType_WIN_EXECUTABLE;
  static const DownloadType CHROME_EXTENSION = ClientDownloadRequest_DownloadType_CHROME_EXTENSION;
  static const DownloadType ANDROID_APK = ClientDownloadRequest_DownloadType_ANDROID_APK;
  static const DownloadType ZIPPED_EXECUTABLE = ClientDownloadRequest_DownloadType_ZIPPED_EXECUTABLE;
  static inline bool DownloadType_IsValid(int value) {
    return ClientDownloadRequest_DownloadType_IsValid(value);
  }
  static const DownloadType DownloadType_MIN =
    ClientDownloadRequest_DownloadType_DownloadType_MIN;
  static const DownloadType DownloadType_MAX =
    ClientDownloadRequest_DownloadType_DownloadType_MAX;
  static const int DownloadType_ARRAYSIZE =
    ClientDownloadRequest_DownloadType_DownloadType_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
  inline bool has_digests() const;
  inline void clear_digests();
  static const int kDigestsFieldNumber = 2;
  inline const ::safe_browsing::ClientDownloadRequest_Digests& digests() const;
  inline ::safe_browsing::ClientDownloadRequest_Digests* mutable_digests();
  inline ::safe_browsing::ClientDownloadRequest_Digests* release_digests();
  
  // required int64 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int64 length() const;
  inline void set_length(::google::protobuf::int64 value);
  
  // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::safe_browsing::ClientDownloadRequest_Resource& resources(int index) const;
  inline ::safe_browsing::ClientDownloadRequest_Resource* mutable_resources(int index);
  inline ::safe_browsing::ClientDownloadRequest_Resource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >*
      mutable_resources();
  
  // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature() const;
  inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* mutable_signature();
  inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* release_signature();
  
  // optional bool user_initiated = 6;
  inline bool has_user_initiated() const;
  inline void clear_user_initiated();
  static const int kUserInitiatedFieldNumber = 6;
  inline bool user_initiated() const;
  inline void set_user_initiated(bool value);
  
  // optional string file_basename = 9;
  inline bool has_file_basename() const;
  inline void clear_file_basename();
  static const int kFileBasenameFieldNumber = 9;
  inline const ::std::string& file_basename() const;
  inline void set_file_basename(const ::std::string& value);
  inline void set_file_basename(const char* value);
  inline void set_file_basename(const char* value, size_t size);
  inline ::std::string* mutable_file_basename();
  inline ::std::string* release_file_basename();
  
  // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
  inline bool has_download_type() const;
  inline void clear_download_type();
  static const int kDownloadTypeFieldNumber = 10;
  inline ::safe_browsing::ClientDownloadRequest_DownloadType download_type() const;
  inline void set_download_type(::safe_browsing::ClientDownloadRequest_DownloadType value);
  
  // optional string locale = 11;
  inline bool has_locale() const;
  inline void clear_locale();
  static const int kLocaleFieldNumber = 11;
  inline const ::std::string& locale() const;
  inline void set_locale(const ::std::string& value);
  inline void set_locale(const char* value);
  inline void set_locale(const char* value, size_t size);
  inline ::std::string* mutable_locale();
  inline ::std::string* release_locale();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadRequest)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_digests();
  inline void clear_has_digests();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_user_initiated();
  inline void clear_has_user_initiated();
  inline void set_has_file_basename();
  inline void clear_has_file_basename();
  inline void set_has_download_type();
  inline void clear_has_download_type();
  inline void set_has_locale();
  inline void clear_has_locale();
  
  ::std::string* url_;
  ::safe_browsing::ClientDownloadRequest_Digests* digests_;
  ::google::protobuf::int64 length_;
  ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource > resources_;
  ::safe_browsing::ClientDownloadRequest_SignatureInfo* signature_;
  ::std::string* file_basename_;
  bool user_initiated_;
  int download_type_;
  ::std::string* locale_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadResponse_MoreInfo : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadResponse_MoreInfo();
  virtual ~ClientDownloadResponse_MoreInfo();
  
  ClientDownloadResponse_MoreInfo(const ClientDownloadResponse_MoreInfo& from);
  
  inline ClientDownloadResponse_MoreInfo& operator=(const ClientDownloadResponse_MoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadResponse_MoreInfo& default_instance();
  
  void Swap(ClientDownloadResponse_MoreInfo* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadResponse_MoreInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadResponse_MoreInfo& from);
  void MergeFrom(const ClientDownloadResponse_MoreInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string description = 1;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 1;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadResponse.MoreInfo)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_url();
  inline void clear_has_url();
  
  ::std::string* description_;
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadResponse_MoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadResponse : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadResponse();
  virtual ~ClientDownloadResponse();
  
  ClientDownloadResponse(const ClientDownloadResponse& from);
  
  inline ClientDownloadResponse& operator=(const ClientDownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadResponse& default_instance();
  
  void Swap(ClientDownloadResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadResponse& from);
  void MergeFrom(const ClientDownloadResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadResponse_MoreInfo MoreInfo;
  
  typedef ClientDownloadResponse_Verdict Verdict;
  static const Verdict SAFE = ClientDownloadResponse_Verdict_SAFE;
  static const Verdict DANGEROUS = ClientDownloadResponse_Verdict_DANGEROUS;
  static const Verdict UNCOMMON = ClientDownloadResponse_Verdict_UNCOMMON;
  static const Verdict POTENTIALLY_UNWANTED = ClientDownloadResponse_Verdict_POTENTIALLY_UNWANTED;
  static const Verdict DANGEROUS_HOST = ClientDownloadResponse_Verdict_DANGEROUS_HOST;
  static inline bool Verdict_IsValid(int value) {
    return ClientDownloadResponse_Verdict_IsValid(value);
  }
  static const Verdict Verdict_MIN =
    ClientDownloadResponse_Verdict_Verdict_MIN;
  static const Verdict Verdict_MAX =
    ClientDownloadResponse_Verdict_Verdict_MAX;
  static const int Verdict_ARRAYSIZE =
    ClientDownloadResponse_Verdict_Verdict_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // required .safe_browsing.ClientDownloadResponse.Verdict verdict = 1;
  inline bool has_verdict() const;
  inline void clear_verdict();
  static const int kVerdictFieldNumber = 1;
  inline ::safe_browsing::ClientDownloadResponse_Verdict verdict() const;
  inline void set_verdict(::safe_browsing::ClientDownloadResponse_Verdict value);
  
  // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
  inline bool has_more_info() const;
  inline void clear_more_info();
  static const int kMoreInfoFieldNumber = 2;
  inline const ::safe_browsing::ClientDownloadResponse_MoreInfo& more_info() const;
  inline ::safe_browsing::ClientDownloadResponse_MoreInfo* mutable_more_info();
  inline ::safe_browsing::ClientDownloadResponse_MoreInfo* release_more_info();
  
  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadResponse)
 private:
  inline void set_has_verdict();
  inline void clear_has_verdict();
  inline void set_has_more_info();
  inline void clear_has_more_info();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::safe_browsing::ClientDownloadResponse_MoreInfo* more_info_;
  ::std::string* token_;
  int verdict_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadReport_UserInformation : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadReport_UserInformation();
  virtual ~ClientDownloadReport_UserInformation();
  
  ClientDownloadReport_UserInformation(const ClientDownloadReport_UserInformation& from);
  
  inline ClientDownloadReport_UserInformation& operator=(const ClientDownloadReport_UserInformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadReport_UserInformation& default_instance();
  
  void Swap(ClientDownloadReport_UserInformation* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadReport_UserInformation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadReport_UserInformation& from);
  void MergeFrom(const ClientDownloadReport_UserInformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadReport.UserInformation)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  
  ::std::string* email_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadReport_UserInformation* default_instance_;
};
// -------------------------------------------------------------------

class ClientDownloadReport : public ::google::protobuf::MessageLite {
 public:
  ClientDownloadReport();
  virtual ~ClientDownloadReport();
  
  ClientDownloadReport(const ClientDownloadReport& from);
  
  inline ClientDownloadReport& operator=(const ClientDownloadReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientDownloadReport& default_instance();
  
  void Swap(ClientDownloadReport* other);
  
  // implements Message ----------------------------------------------
  
  ClientDownloadReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientDownloadReport& from);
  void MergeFrom(const ClientDownloadReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientDownloadReport_UserInformation UserInformation;
  
  typedef ClientDownloadReport_Reason Reason;
  static const Reason SHARE = ClientDownloadReport_Reason_SHARE;
  static const Reason FALSE_POSITIVE = ClientDownloadReport_Reason_FALSE_POSITIVE;
  static const Reason APPEAL = ClientDownloadReport_Reason_APPEAL;
  static inline bool Reason_IsValid(int value) {
    return ClientDownloadReport_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    ClientDownloadReport_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    ClientDownloadReport_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    ClientDownloadReport_Reason_Reason_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::safe_browsing::ClientDownloadReport_Reason reason() const;
  inline void set_reason(::safe_browsing::ClientDownloadReport_Reason value);
  
  // optional .safe_browsing.ClientDownloadRequest download_request = 2;
  inline bool has_download_request() const;
  inline void clear_download_request();
  static const int kDownloadRequestFieldNumber = 2;
  inline const ::safe_browsing::ClientDownloadRequest& download_request() const;
  inline ::safe_browsing::ClientDownloadRequest* mutable_download_request();
  inline ::safe_browsing::ClientDownloadRequest* release_download_request();
  
  // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
  inline bool has_user_information() const;
  inline void clear_user_information();
  static const int kUserInformationFieldNumber = 3;
  inline const ::safe_browsing::ClientDownloadReport_UserInformation& user_information() const;
  inline ::safe_browsing::ClientDownloadReport_UserInformation* mutable_user_information();
  inline ::safe_browsing::ClientDownloadReport_UserInformation* release_user_information();
  
  // optional bytes comment = 4;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 4;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const void* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  
  // optional .safe_browsing.ClientDownloadResponse download_response = 5;
  inline bool has_download_response() const;
  inline void clear_download_response();
  static const int kDownloadResponseFieldNumber = 5;
  inline const ::safe_browsing::ClientDownloadResponse& download_response() const;
  inline ::safe_browsing::ClientDownloadResponse* mutable_download_response();
  inline ::safe_browsing::ClientDownloadResponse* release_download_response();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientDownloadReport)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_download_request();
  inline void clear_has_download_request();
  inline void set_has_user_information();
  inline void clear_has_user_information();
  inline void set_has_comment();
  inline void clear_has_comment();
  inline void set_has_download_response();
  inline void clear_has_download_response();
  
  ::safe_browsing::ClientDownloadRequest* download_request_;
  ::safe_browsing::ClientDownloadReport_UserInformation* user_information_;
  ::std::string* comment_;
  ::safe_browsing::ClientDownloadResponse* download_response_;
  int reason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientDownloadReport* default_instance_;
};
// -------------------------------------------------------------------

class ClientUploadResponse : public ::google::protobuf::MessageLite {
 public:
  ClientUploadResponse();
  virtual ~ClientUploadResponse();
  
  ClientUploadResponse(const ClientUploadResponse& from);
  
  inline ClientUploadResponse& operator=(const ClientUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const ClientUploadResponse& default_instance();
  
  void Swap(ClientUploadResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientUploadResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientUploadResponse& from);
  void MergeFrom(const ClientUploadResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientUploadResponse_UploadStatus UploadStatus;
  static const UploadStatus SUCCESS = ClientUploadResponse_UploadStatus_SUCCESS;
  static const UploadStatus UPLOAD_FAILURE = ClientUploadResponse_UploadStatus_UPLOAD_FAILURE;
  static inline bool UploadStatus_IsValid(int value) {
    return ClientUploadResponse_UploadStatus_IsValid(value);
  }
  static const UploadStatus UploadStatus_MIN =
    ClientUploadResponse_UploadStatus_UploadStatus_MIN;
  static const UploadStatus UploadStatus_MAX =
    ClientUploadResponse_UploadStatus_UploadStatus_MAX;
  static const int UploadStatus_ARRAYSIZE =
    ClientUploadResponse_UploadStatus_UploadStatus_ARRAYSIZE;
  
  // accessors -------------------------------------------------------
  
  // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::safe_browsing::ClientUploadResponse_UploadStatus status() const;
  inline void set_status(::safe_browsing::ClientUploadResponse_UploadStatus value);
  
  // optional string permalink = 2;
  inline bool has_permalink() const;
  inline void clear_permalink();
  static const int kPermalinkFieldNumber = 2;
  inline const ::std::string& permalink() const;
  inline void set_permalink(const ::std::string& value);
  inline void set_permalink(const char* value);
  inline void set_permalink(const char* value, size_t size);
  inline ::std::string* mutable_permalink();
  inline ::std::string* release_permalink();
  
  // @@protoc_insertion_point(class_scope:safe_browsing.ClientUploadResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_permalink();
  inline void clear_has_permalink();
  
  ::std::string* permalink_;
  int status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_csd_2eproto();
  friend void protobuf_AssignDesc_csd_2eproto();
  friend void protobuf_ShutdownFile_csd_2eproto();
  
  void InitAsDefaultInstance();
  static ClientUploadResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientPhishingRequest_Feature

// required string name = 1;
inline bool ClientPhishingRequest_Feature::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientPhishingRequest_Feature::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientPhishingRequest_Feature::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientPhishingRequest_Feature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientPhishingRequest_Feature::name() const {
  return *name_;
}
inline void ClientPhishingRequest_Feature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientPhishingRequest_Feature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientPhishingRequest_Feature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientPhishingRequest_Feature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientPhishingRequest_Feature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double value = 2;
inline bool ClientPhishingRequest_Feature::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientPhishingRequest_Feature::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientPhishingRequest_Feature::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientPhishingRequest_Feature::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double ClientPhishingRequest_Feature::value() const {
  return value_;
}
inline void ClientPhishingRequest_Feature::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ClientPhishingRequest

// optional string url = 1;
inline bool ClientPhishingRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientPhishingRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientPhishingRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientPhishingRequest::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientPhishingRequest::url() const {
  return *url_;
}
inline void ClientPhishingRequest::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientPhishingRequest::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientPhishingRequest::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientPhishingRequest::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientPhishingRequest::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes OBSOLETE_hash_prefix = 10;
inline bool ClientPhishingRequest::has_obsolete_hash_prefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientPhishingRequest::set_has_obsolete_hash_prefix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientPhishingRequest::clear_has_obsolete_hash_prefix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientPhishingRequest::clear_obsolete_hash_prefix() {
  if (obsolete_hash_prefix_ != &::google::protobuf::internal::kEmptyString) {
    obsolete_hash_prefix_->clear();
  }
  clear_has_obsolete_hash_prefix();
}
inline const ::std::string& ClientPhishingRequest::obsolete_hash_prefix() const {
  return *obsolete_hash_prefix_;
}
inline void ClientPhishingRequest::set_obsolete_hash_prefix(const ::std::string& value) {
  set_has_obsolete_hash_prefix();
  if (obsolete_hash_prefix_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_hash_prefix_ = new ::std::string;
  }
  obsolete_hash_prefix_->assign(value);
}
inline void ClientPhishingRequest::set_obsolete_hash_prefix(const char* value) {
  set_has_obsolete_hash_prefix();
  if (obsolete_hash_prefix_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_hash_prefix_ = new ::std::string;
  }
  obsolete_hash_prefix_->assign(value);
}
inline void ClientPhishingRequest::set_obsolete_hash_prefix(const void* value, size_t size) {
  set_has_obsolete_hash_prefix();
  if (obsolete_hash_prefix_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_hash_prefix_ = new ::std::string;
  }
  obsolete_hash_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientPhishingRequest::mutable_obsolete_hash_prefix() {
  set_has_obsolete_hash_prefix();
  if (obsolete_hash_prefix_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_hash_prefix_ = new ::std::string;
  }
  return obsolete_hash_prefix_;
}
inline ::std::string* ClientPhishingRequest::release_obsolete_hash_prefix() {
  clear_has_obsolete_hash_prefix();
  if (obsolete_hash_prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = obsolete_hash_prefix_;
    obsolete_hash_prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float client_score = 2;
inline bool ClientPhishingRequest::has_client_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientPhishingRequest::set_has_client_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientPhishingRequest::clear_has_client_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientPhishingRequest::clear_client_score() {
  client_score_ = 0;
  clear_has_client_score();
}
inline float ClientPhishingRequest::client_score() const {
  return client_score_;
}
inline void ClientPhishingRequest::set_client_score(float value) {
  set_has_client_score();
  client_score_ = value;
}

// optional bool is_phishing = 4;
inline bool ClientPhishingRequest::has_is_phishing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientPhishingRequest::set_has_is_phishing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientPhishingRequest::clear_has_is_phishing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientPhishingRequest::clear_is_phishing() {
  is_phishing_ = false;
  clear_has_is_phishing();
}
inline bool ClientPhishingRequest::is_phishing() const {
  return is_phishing_;
}
inline void ClientPhishingRequest::set_is_phishing(bool value) {
  set_has_is_phishing();
  is_phishing_ = value;
}

// repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
inline int ClientPhishingRequest::feature_map_size() const {
  return feature_map_.size();
}
inline void ClientPhishingRequest::clear_feature_map() {
  feature_map_.Clear();
}
inline const ::safe_browsing::ClientPhishingRequest_Feature& ClientPhishingRequest::feature_map(int index) const {
  return feature_map_.Get(index);
}
inline ::safe_browsing::ClientPhishingRequest_Feature* ClientPhishingRequest::mutable_feature_map(int index) {
  return feature_map_.Mutable(index);
}
inline ::safe_browsing::ClientPhishingRequest_Feature* ClientPhishingRequest::add_feature_map() {
  return feature_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >&
ClientPhishingRequest::feature_map() const {
  return feature_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >*
ClientPhishingRequest::mutable_feature_map() {
  return &feature_map_;
}

// optional int32 model_version = 6;
inline bool ClientPhishingRequest::has_model_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientPhishingRequest::set_has_model_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientPhishingRequest::clear_has_model_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientPhishingRequest::clear_model_version() {
  model_version_ = 0;
  clear_has_model_version();
}
inline ::google::protobuf::int32 ClientPhishingRequest::model_version() const {
  return model_version_;
}
inline void ClientPhishingRequest::set_model_version(::google::protobuf::int32 value) {
  set_has_model_version();
  model_version_ = value;
}

// repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
inline int ClientPhishingRequest::non_model_feature_map_size() const {
  return non_model_feature_map_.size();
}
inline void ClientPhishingRequest::clear_non_model_feature_map() {
  non_model_feature_map_.Clear();
}
inline const ::safe_browsing::ClientPhishingRequest_Feature& ClientPhishingRequest::non_model_feature_map(int index) const {
  return non_model_feature_map_.Get(index);
}
inline ::safe_browsing::ClientPhishingRequest_Feature* ClientPhishingRequest::mutable_non_model_feature_map(int index) {
  return non_model_feature_map_.Mutable(index);
}
inline ::safe_browsing::ClientPhishingRequest_Feature* ClientPhishingRequest::add_non_model_feature_map() {
  return non_model_feature_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >&
ClientPhishingRequest::non_model_feature_map() const {
  return non_model_feature_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientPhishingRequest_Feature >*
ClientPhishingRequest::mutable_non_model_feature_map() {
  return &non_model_feature_map_;
}

// optional string OBSOLETE_referrer_url = 9;
inline bool ClientPhishingRequest::has_obsolete_referrer_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientPhishingRequest::set_has_obsolete_referrer_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientPhishingRequest::clear_has_obsolete_referrer_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientPhishingRequest::clear_obsolete_referrer_url() {
  if (obsolete_referrer_url_ != &::google::protobuf::internal::kEmptyString) {
    obsolete_referrer_url_->clear();
  }
  clear_has_obsolete_referrer_url();
}
inline const ::std::string& ClientPhishingRequest::obsolete_referrer_url() const {
  return *obsolete_referrer_url_;
}
inline void ClientPhishingRequest::set_obsolete_referrer_url(const ::std::string& value) {
  set_has_obsolete_referrer_url();
  if (obsolete_referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_referrer_url_ = new ::std::string;
  }
  obsolete_referrer_url_->assign(value);
}
inline void ClientPhishingRequest::set_obsolete_referrer_url(const char* value) {
  set_has_obsolete_referrer_url();
  if (obsolete_referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_referrer_url_ = new ::std::string;
  }
  obsolete_referrer_url_->assign(value);
}
inline void ClientPhishingRequest::set_obsolete_referrer_url(const char* value, size_t size) {
  set_has_obsolete_referrer_url();
  if (obsolete_referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_referrer_url_ = new ::std::string;
  }
  obsolete_referrer_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientPhishingRequest::mutable_obsolete_referrer_url() {
  set_has_obsolete_referrer_url();
  if (obsolete_referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    obsolete_referrer_url_ = new ::std::string;
  }
  return obsolete_referrer_url_;
}
inline ::std::string* ClientPhishingRequest::release_obsolete_referrer_url() {
  clear_has_obsolete_referrer_url();
  if (obsolete_referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = obsolete_referrer_url_;
    obsolete_referrer_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientPhishingResponse

// required bool phishy = 1;
inline bool ClientPhishingResponse::has_phishy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientPhishingResponse::set_has_phishy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientPhishingResponse::clear_has_phishy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientPhishingResponse::clear_phishy() {
  phishy_ = false;
  clear_has_phishy();
}
inline bool ClientPhishingResponse::phishy() const {
  return phishy_;
}
inline void ClientPhishingResponse::set_phishy(bool value) {
  set_has_phishy();
  phishy_ = value;
}

// repeated string OBSOLETE_whitelist_expression = 2;
inline int ClientPhishingResponse::obsolete_whitelist_expression_size() const {
  return obsolete_whitelist_expression_.size();
}
inline void ClientPhishingResponse::clear_obsolete_whitelist_expression() {
  obsolete_whitelist_expression_.Clear();
}
inline const ::std::string& ClientPhishingResponse::obsolete_whitelist_expression(int index) const {
  return obsolete_whitelist_expression_.Get(index);
}
inline ::std::string* ClientPhishingResponse::mutable_obsolete_whitelist_expression(int index) {
  return obsolete_whitelist_expression_.Mutable(index);
}
inline void ClientPhishingResponse::set_obsolete_whitelist_expression(int index, const ::std::string& value) {
  obsolete_whitelist_expression_.Mutable(index)->assign(value);
}
inline void ClientPhishingResponse::set_obsolete_whitelist_expression(int index, const char* value) {
  obsolete_whitelist_expression_.Mutable(index)->assign(value);
}
inline void ClientPhishingResponse::set_obsolete_whitelist_expression(int index, const char* value, size_t size) {
  obsolete_whitelist_expression_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientPhishingResponse::add_obsolete_whitelist_expression() {
  return obsolete_whitelist_expression_.Add();
}
inline void ClientPhishingResponse::add_obsolete_whitelist_expression(const ::std::string& value) {
  obsolete_whitelist_expression_.Add()->assign(value);
}
inline void ClientPhishingResponse::add_obsolete_whitelist_expression(const char* value) {
  obsolete_whitelist_expression_.Add()->assign(value);
}
inline void ClientPhishingResponse::add_obsolete_whitelist_expression(const char* value, size_t size) {
  obsolete_whitelist_expression_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientPhishingResponse::obsolete_whitelist_expression() const {
  return obsolete_whitelist_expression_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientPhishingResponse::mutable_obsolete_whitelist_expression() {
  return &obsolete_whitelist_expression_;
}

// -------------------------------------------------------------------

// ClientMalwareRequest_Feature

// required string name = 1;
inline bool ClientMalwareRequest_Feature::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMalwareRequest_Feature::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMalwareRequest_Feature::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMalwareRequest_Feature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientMalwareRequest_Feature::name() const {
  return *name_;
}
inline void ClientMalwareRequest_Feature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientMalwareRequest_Feature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientMalwareRequest_Feature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMalwareRequest_Feature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientMalwareRequest_Feature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double value = 2;
inline bool ClientMalwareRequest_Feature::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMalwareRequest_Feature::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMalwareRequest_Feature::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMalwareRequest_Feature::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double ClientMalwareRequest_Feature::value() const {
  return value_;
}
inline void ClientMalwareRequest_Feature::set_value(double value) {
  set_has_value();
  value_ = value;
}

// repeated string metainfo = 3;
inline int ClientMalwareRequest_Feature::metainfo_size() const {
  return metainfo_.size();
}
inline void ClientMalwareRequest_Feature::clear_metainfo() {
  metainfo_.Clear();
}
inline const ::std::string& ClientMalwareRequest_Feature::metainfo(int index) const {
  return metainfo_.Get(index);
}
inline ::std::string* ClientMalwareRequest_Feature::mutable_metainfo(int index) {
  return metainfo_.Mutable(index);
}
inline void ClientMalwareRequest_Feature::set_metainfo(int index, const ::std::string& value) {
  metainfo_.Mutable(index)->assign(value);
}
inline void ClientMalwareRequest_Feature::set_metainfo(int index, const char* value) {
  metainfo_.Mutable(index)->assign(value);
}
inline void ClientMalwareRequest_Feature::set_metainfo(int index, const char* value, size_t size) {
  metainfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMalwareRequest_Feature::add_metainfo() {
  return metainfo_.Add();
}
inline void ClientMalwareRequest_Feature::add_metainfo(const ::std::string& value) {
  metainfo_.Add()->assign(value);
}
inline void ClientMalwareRequest_Feature::add_metainfo(const char* value) {
  metainfo_.Add()->assign(value);
}
inline void ClientMalwareRequest_Feature::add_metainfo(const char* value, size_t size) {
  metainfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientMalwareRequest_Feature::metainfo() const {
  return metainfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientMalwareRequest_Feature::mutable_metainfo() {
  return &metainfo_;
}

// -------------------------------------------------------------------

// ClientMalwareRequest

// required string url = 1;
inline bool ClientMalwareRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMalwareRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMalwareRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMalwareRequest::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientMalwareRequest::url() const {
  return *url_;
}
inline void ClientMalwareRequest::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientMalwareRequest::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientMalwareRequest::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMalwareRequest::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientMalwareRequest::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .safe_browsing.ClientMalwareRequest.Feature feature_map = 2;
inline int ClientMalwareRequest::feature_map_size() const {
  return feature_map_.size();
}
inline void ClientMalwareRequest::clear_feature_map() {
  feature_map_.Clear();
}
inline const ::safe_browsing::ClientMalwareRequest_Feature& ClientMalwareRequest::feature_map(int index) const {
  return feature_map_.Get(index);
}
inline ::safe_browsing::ClientMalwareRequest_Feature* ClientMalwareRequest::mutable_feature_map(int index) {
  return feature_map_.Mutable(index);
}
inline ::safe_browsing::ClientMalwareRequest_Feature* ClientMalwareRequest::add_feature_map() {
  return feature_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientMalwareRequest_Feature >&
ClientMalwareRequest::feature_map() const {
  return feature_map_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientMalwareRequest_Feature >*
ClientMalwareRequest::mutable_feature_map() {
  return &feature_map_;
}

// optional string referrer_url = 4;
inline bool ClientMalwareRequest::has_referrer_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMalwareRequest::set_has_referrer_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMalwareRequest::clear_has_referrer_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMalwareRequest::clear_referrer_url() {
  if (referrer_url_ != &::google::protobuf::internal::kEmptyString) {
    referrer_url_->clear();
  }
  clear_has_referrer_url();
}
inline const ::std::string& ClientMalwareRequest::referrer_url() const {
  return *referrer_url_;
}
inline void ClientMalwareRequest::set_referrer_url(const ::std::string& value) {
  set_has_referrer_url();
  if (referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    referrer_url_ = new ::std::string;
  }
  referrer_url_->assign(value);
}
inline void ClientMalwareRequest::set_referrer_url(const char* value) {
  set_has_referrer_url();
  if (referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    referrer_url_ = new ::std::string;
  }
  referrer_url_->assign(value);
}
inline void ClientMalwareRequest::set_referrer_url(const char* value, size_t size) {
  set_has_referrer_url();
  if (referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    referrer_url_ = new ::std::string;
  }
  referrer_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMalwareRequest::mutable_referrer_url() {
  set_has_referrer_url();
  if (referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    referrer_url_ = new ::std::string;
  }
  return referrer_url_;
}
inline ::std::string* ClientMalwareRequest::release_referrer_url() {
  clear_has_referrer_url();
  if (referrer_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = referrer_url_;
    referrer_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientMalwareResponse

// required bool blacklist = 1;
inline bool ClientMalwareResponse::has_blacklist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMalwareResponse::set_has_blacklist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMalwareResponse::clear_has_blacklist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMalwareResponse::clear_blacklist() {
  blacklist_ = false;
  clear_has_blacklist();
}
inline bool ClientMalwareResponse::blacklist() const {
  return blacklist_;
}
inline void ClientMalwareResponse::set_blacklist(bool value) {
  set_has_blacklist();
  blacklist_ = value;
}

// optional string bad_ip = 2;
inline bool ClientMalwareResponse::has_bad_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMalwareResponse::set_has_bad_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMalwareResponse::clear_has_bad_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMalwareResponse::clear_bad_ip() {
  if (bad_ip_ != &::google::protobuf::internal::kEmptyString) {
    bad_ip_->clear();
  }
  clear_has_bad_ip();
}
inline const ::std::string& ClientMalwareResponse::bad_ip() const {
  return *bad_ip_;
}
inline void ClientMalwareResponse::set_bad_ip(const ::std::string& value) {
  set_has_bad_ip();
  if (bad_ip_ == &::google::protobuf::internal::kEmptyString) {
    bad_ip_ = new ::std::string;
  }
  bad_ip_->assign(value);
}
inline void ClientMalwareResponse::set_bad_ip(const char* value) {
  set_has_bad_ip();
  if (bad_ip_ == &::google::protobuf::internal::kEmptyString) {
    bad_ip_ = new ::std::string;
  }
  bad_ip_->assign(value);
}
inline void ClientMalwareResponse::set_bad_ip(const char* value, size_t size) {
  set_has_bad_ip();
  if (bad_ip_ == &::google::protobuf::internal::kEmptyString) {
    bad_ip_ = new ::std::string;
  }
  bad_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientMalwareResponse::mutable_bad_ip() {
  set_has_bad_ip();
  if (bad_ip_ == &::google::protobuf::internal::kEmptyString) {
    bad_ip_ = new ::std::string;
  }
  return bad_ip_;
}
inline ::std::string* ClientMalwareResponse::release_bad_ip() {
  clear_has_bad_ip();
  if (bad_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bad_ip_;
    bad_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_Digests

// optional bytes sha256 = 1;
inline bool ClientDownloadRequest_Digests::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_sha256() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_Digests::clear_has_sha256() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_Digests::clear_sha256() {
  if (sha256_ != &::google::protobuf::internal::kEmptyString) {
    sha256_->clear();
  }
  clear_has_sha256();
}
inline const ::std::string& ClientDownloadRequest_Digests::sha256() const {
  return *sha256_;
}
inline void ClientDownloadRequest_Digests::set_sha256(const ::std::string& value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha256(const char* value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha256(const void* value, size_t size) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_sha256() {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    sha256_ = new ::std::string;
  }
  return sha256_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_sha256() {
  clear_has_sha256();
  if (sha256_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha256_;
    sha256_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes sha1 = 2;
inline bool ClientDownloadRequest_Digests::has_sha1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_sha1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_Digests::clear_has_sha1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_Digests::clear_sha1() {
  if (sha1_ != &::google::protobuf::internal::kEmptyString) {
    sha1_->clear();
  }
  clear_has_sha1();
}
inline const ::std::string& ClientDownloadRequest_Digests::sha1() const {
  return *sha1_;
}
inline void ClientDownloadRequest_Digests::set_sha1(const ::std::string& value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha1(const char* value) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_sha1(const void* value, size_t size) {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  sha1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_sha1() {
  set_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    sha1_ = new ::std::string;
  }
  return sha1_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_sha1() {
  clear_has_sha1();
  if (sha1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sha1_;
    sha1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes md5 = 3;
inline bool ClientDownloadRequest_Digests::has_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest_Digests::set_has_md5() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest_Digests::clear_has_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest_Digests::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& ClientDownloadRequest_Digests::md5() const {
  return *md5_;
}
inline void ClientDownloadRequest_Digests::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ClientDownloadRequest_Digests::set_md5(const void* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Digests::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* ClientDownloadRequest_Digests::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_Resource

// required string url = 1;
inline bool ClientDownloadRequest_Resource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_Resource::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_Resource::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadRequest_Resource::url() const {
  return *url_;
}
inline void ClientDownloadRequest_Resource::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
inline bool ClientDownloadRequest_Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::safe_browsing::ClientDownloadRequest_ResourceType ClientDownloadRequest_Resource::type() const {
  return static_cast< ::safe_browsing::ClientDownloadRequest_ResourceType >(type_);
}
inline void ClientDownloadRequest_Resource::set_type(::safe_browsing::ClientDownloadRequest_ResourceType value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadRequest_ResourceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes remote_ip = 3;
inline bool ClientDownloadRequest_Resource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest_Resource::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest_Resource::clear_remote_ip() {
  if (remote_ip_ != &::google::protobuf::internal::kEmptyString) {
    remote_ip_->clear();
  }
  clear_has_remote_ip();
}
inline const ::std::string& ClientDownloadRequest_Resource::remote_ip() const {
  return *remote_ip_;
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const char* value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_remote_ip(const void* value, size_t size) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_remote_ip() {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    remote_ip_ = new ::std::string;
  }
  return remote_ip_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_remote_ip() {
  clear_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remote_ip_;
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string referrer = 4;
inline bool ClientDownloadRequest_Resource::has_referrer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientDownloadRequest_Resource::set_has_referrer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientDownloadRequest_Resource::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientDownloadRequest_Resource::clear_referrer() {
  if (referrer_ != &::google::protobuf::internal::kEmptyString) {
    referrer_->clear();
  }
  clear_has_referrer();
}
inline const ::std::string& ClientDownloadRequest_Resource::referrer() const {
  return *referrer_;
}
inline void ClientDownloadRequest_Resource::set_referrer(const ::std::string& value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_referrer(const char* value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void ClientDownloadRequest_Resource::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_Resource::mutable_referrer() {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    referrer_ = new ::std::string;
  }
  return referrer_;
}
inline ::std::string* ClientDownloadRequest_Resource::release_referrer() {
  clear_has_referrer();
  if (referrer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = referrer_;
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_CertificateChain_Element

// optional bytes certificate = 1;
inline bool ClientDownloadRequest_CertificateChain_Element::has_certificate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest_CertificateChain_Element::set_has_certificate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest_CertificateChain_Element::clear_has_certificate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest_CertificateChain_Element::clear_certificate() {
  if (certificate_ != &::google::protobuf::internal::kEmptyString) {
    certificate_->clear();
  }
  clear_has_certificate();
}
inline const ::std::string& ClientDownloadRequest_CertificateChain_Element::certificate() const {
  return *certificate_;
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const ::std::string& value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const char* value) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(value);
}
inline void ClientDownloadRequest_CertificateChain_Element::set_certificate(const void* value, size_t size) {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest_CertificateChain_Element::mutable_certificate() {
  set_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    certificate_ = new ::std::string;
  }
  return certificate_;
}
inline ::std::string* ClientDownloadRequest_CertificateChain_Element::release_certificate() {
  clear_has_certificate();
  if (certificate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = certificate_;
    certificate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadRequest_CertificateChain

// repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
inline int ClientDownloadRequest_CertificateChain::element_size() const {
  return element_.size();
}
inline void ClientDownloadRequest_CertificateChain::clear_element() {
  element_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_CertificateChain_Element& ClientDownloadRequest_CertificateChain::element(int index) const {
  return element_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* ClientDownloadRequest_CertificateChain::mutable_element(int index) {
  return element_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain_Element* ClientDownloadRequest_CertificateChain::add_element() {
  return element_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >&
ClientDownloadRequest_CertificateChain::element() const {
  return element_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain_Element >*
ClientDownloadRequest_CertificateChain::mutable_element() {
  return &element_;
}

// -------------------------------------------------------------------

// ClientDownloadRequest_SignatureInfo

// repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
inline int ClientDownloadRequest_SignatureInfo::certificate_chain_size() const {
  return certificate_chain_.size();
}
inline void ClientDownloadRequest_SignatureInfo::clear_certificate_chain() {
  certificate_chain_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_CertificateChain& ClientDownloadRequest_SignatureInfo::certificate_chain(int index) const {
  return certificate_chain_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain* ClientDownloadRequest_SignatureInfo::mutable_certificate_chain(int index) {
  return certificate_chain_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_CertificateChain* ClientDownloadRequest_SignatureInfo::add_certificate_chain() {
  return certificate_chain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >&
ClientDownloadRequest_SignatureInfo::certificate_chain() const {
  return certificate_chain_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_CertificateChain >*
ClientDownloadRequest_SignatureInfo::mutable_certificate_chain() {
  return &certificate_chain_;
}

// optional bool trusted = 2;
inline bool ClientDownloadRequest_SignatureInfo::has_trusted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest_SignatureInfo::set_has_trusted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest_SignatureInfo::clear_has_trusted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest_SignatureInfo::clear_trusted() {
  trusted_ = false;
  clear_has_trusted();
}
inline bool ClientDownloadRequest_SignatureInfo::trusted() const {
  return trusted_;
}
inline void ClientDownloadRequest_SignatureInfo::set_trusted(bool value) {
  set_has_trusted();
  trusted_ = value;
}

// -------------------------------------------------------------------

// ClientDownloadRequest

// required string url = 1;
inline bool ClientDownloadRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadRequest::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadRequest::url() const {
  return *url_;
}
inline void ClientDownloadRequest::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadRequest::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadRequest::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
inline bool ClientDownloadRequest::has_digests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadRequest::set_has_digests() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadRequest::clear_has_digests() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadRequest::clear_digests() {
  if (digests_ != NULL) digests_->::safe_browsing::ClientDownloadRequest_Digests::Clear();
  clear_has_digests();
}
inline const ::safe_browsing::ClientDownloadRequest_Digests& ClientDownloadRequest::digests() const {
  return digests_ != NULL ? *digests_ : *default_instance_->digests_;
}
inline ::safe_browsing::ClientDownloadRequest_Digests* ClientDownloadRequest::mutable_digests() {
  set_has_digests();
  if (digests_ == NULL) digests_ = new ::safe_browsing::ClientDownloadRequest_Digests;
  return digests_;
}
inline ::safe_browsing::ClientDownloadRequest_Digests* ClientDownloadRequest::release_digests() {
  clear_has_digests();
  ::safe_browsing::ClientDownloadRequest_Digests* temp = digests_;
  digests_ = NULL;
  return temp;
}

// required int64 length = 3;
inline bool ClientDownloadRequest::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadRequest::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadRequest::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::int64 ClientDownloadRequest::length() const {
  return length_;
}
inline void ClientDownloadRequest::set_length(::google::protobuf::int64 value) {
  set_has_length();
  length_ = value;
}

// repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
inline int ClientDownloadRequest::resources_size() const {
  return resources_.size();
}
inline void ClientDownloadRequest::clear_resources() {
  resources_.Clear();
}
inline const ::safe_browsing::ClientDownloadRequest_Resource& ClientDownloadRequest::resources(int index) const {
  return resources_.Get(index);
}
inline ::safe_browsing::ClientDownloadRequest_Resource* ClientDownloadRequest::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::safe_browsing::ClientDownloadRequest_Resource* ClientDownloadRequest::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >&
ClientDownloadRequest::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::safe_browsing::ClientDownloadRequest_Resource >*
ClientDownloadRequest::mutable_resources() {
  return &resources_;
}

// optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
inline bool ClientDownloadRequest::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientDownloadRequest::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientDownloadRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientDownloadRequest::clear_signature() {
  if (signature_ != NULL) signature_->::safe_browsing::ClientDownloadRequest_SignatureInfo::Clear();
  clear_has_signature();
}
inline const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientDownloadRequest::signature() const {
  return signature_ != NULL ? *signature_ : *default_instance_->signature_;
}
inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* ClientDownloadRequest::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo;
  return signature_;
}
inline ::safe_browsing::ClientDownloadRequest_SignatureInfo* ClientDownloadRequest::release_signature() {
  clear_has_signature();
  ::safe_browsing::ClientDownloadRequest_SignatureInfo* temp = signature_;
  signature_ = NULL;
  return temp;
}

// optional bool user_initiated = 6;
inline bool ClientDownloadRequest::has_user_initiated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientDownloadRequest::set_has_user_initiated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientDownloadRequest::clear_has_user_initiated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientDownloadRequest::clear_user_initiated() {
  user_initiated_ = false;
  clear_has_user_initiated();
}
inline bool ClientDownloadRequest::user_initiated() const {
  return user_initiated_;
}
inline void ClientDownloadRequest::set_user_initiated(bool value) {
  set_has_user_initiated();
  user_initiated_ = value;
}

// optional string file_basename = 9;
inline bool ClientDownloadRequest::has_file_basename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientDownloadRequest::set_has_file_basename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientDownloadRequest::clear_has_file_basename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientDownloadRequest::clear_file_basename() {
  if (file_basename_ != &::google::protobuf::internal::kEmptyString) {
    file_basename_->clear();
  }
  clear_has_file_basename();
}
inline const ::std::string& ClientDownloadRequest::file_basename() const {
  return *file_basename_;
}
inline void ClientDownloadRequest::set_file_basename(const ::std::string& value) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(value);
}
inline void ClientDownloadRequest::set_file_basename(const char* value) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(value);
}
inline void ClientDownloadRequest::set_file_basename(const char* value, size_t size) {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  file_basename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_file_basename() {
  set_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    file_basename_ = new ::std::string;
  }
  return file_basename_;
}
inline ::std::string* ClientDownloadRequest::release_file_basename() {
  clear_has_file_basename();
  if (file_basename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_basename_;
    file_basename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
inline bool ClientDownloadRequest::has_download_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientDownloadRequest::set_has_download_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientDownloadRequest::clear_has_download_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientDownloadRequest::clear_download_type() {
  download_type_ = 0;
  clear_has_download_type();
}
inline ::safe_browsing::ClientDownloadRequest_DownloadType ClientDownloadRequest::download_type() const {
  return static_cast< ::safe_browsing::ClientDownloadRequest_DownloadType >(download_type_);
}
inline void ClientDownloadRequest::set_download_type(::safe_browsing::ClientDownloadRequest_DownloadType value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(value));
  set_has_download_type();
  download_type_ = value;
}

// optional string locale = 11;
inline bool ClientDownloadRequest::has_locale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientDownloadRequest::set_has_locale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientDownloadRequest::clear_has_locale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientDownloadRequest::clear_locale() {
  if (locale_ != &::google::protobuf::internal::kEmptyString) {
    locale_->clear();
  }
  clear_has_locale();
}
inline const ::std::string& ClientDownloadRequest::locale() const {
  return *locale_;
}
inline void ClientDownloadRequest::set_locale(const ::std::string& value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void ClientDownloadRequest::set_locale(const char* value) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(value);
}
inline void ClientDownloadRequest::set_locale(const char* value, size_t size) {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  locale_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadRequest::mutable_locale() {
  set_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    locale_ = new ::std::string;
  }
  return locale_;
}
inline ::std::string* ClientDownloadRequest::release_locale() {
  clear_has_locale();
  if (locale_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_;
    locale_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadResponse_MoreInfo

// optional string description = 1;
inline bool ClientDownloadResponse_MoreInfo::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadResponse_MoreInfo::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadResponse_MoreInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadResponse_MoreInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ClientDownloadResponse_MoreInfo::description() const {
  return *description_;
}
inline void ClientDownloadResponse_MoreInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse_MoreInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ClientDownloadResponse_MoreInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string url = 2;
inline bool ClientDownloadResponse_MoreInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadResponse_MoreInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadResponse_MoreInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadResponse_MoreInfo::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientDownloadResponse_MoreInfo::url() const {
  return *url_;
}
inline void ClientDownloadResponse_MoreInfo::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientDownloadResponse_MoreInfo::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse_MoreInfo::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientDownloadResponse_MoreInfo::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadResponse

// required .safe_browsing.ClientDownloadResponse.Verdict verdict = 1;
inline bool ClientDownloadResponse::has_verdict() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadResponse::set_has_verdict() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadResponse::clear_has_verdict() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadResponse::clear_verdict() {
  verdict_ = 0;
  clear_has_verdict();
}
inline ::safe_browsing::ClientDownloadResponse_Verdict ClientDownloadResponse::verdict() const {
  return static_cast< ::safe_browsing::ClientDownloadResponse_Verdict >(verdict_);
}
inline void ClientDownloadResponse::set_verdict(::safe_browsing::ClientDownloadResponse_Verdict value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(value));
  set_has_verdict();
  verdict_ = value;
}

// optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
inline bool ClientDownloadResponse::has_more_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadResponse::set_has_more_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadResponse::clear_has_more_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadResponse::clear_more_info() {
  if (more_info_ != NULL) more_info_->::safe_browsing::ClientDownloadResponse_MoreInfo::Clear();
  clear_has_more_info();
}
inline const ::safe_browsing::ClientDownloadResponse_MoreInfo& ClientDownloadResponse::more_info() const {
  return more_info_ != NULL ? *more_info_ : *default_instance_->more_info_;
}
inline ::safe_browsing::ClientDownloadResponse_MoreInfo* ClientDownloadResponse::mutable_more_info() {
  set_has_more_info();
  if (more_info_ == NULL) more_info_ = new ::safe_browsing::ClientDownloadResponse_MoreInfo;
  return more_info_;
}
inline ::safe_browsing::ClientDownloadResponse_MoreInfo* ClientDownloadResponse::release_more_info() {
  clear_has_more_info();
  ::safe_browsing::ClientDownloadResponse_MoreInfo* temp = more_info_;
  more_info_ = NULL;
  return temp;
}

// optional bytes token = 3;
inline bool ClientDownloadResponse::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadResponse::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ClientDownloadResponse::token() const {
  return *token_;
}
inline void ClientDownloadResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientDownloadResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ClientDownloadResponse::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ClientDownloadResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadReport_UserInformation

// optional string email = 1;
inline bool ClientDownloadReport_UserInformation::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadReport_UserInformation::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadReport_UserInformation::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadReport_UserInformation::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& ClientDownloadReport_UserInformation::email() const {
  return *email_;
}
inline void ClientDownloadReport_UserInformation::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void ClientDownloadReport_UserInformation::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void ClientDownloadReport_UserInformation::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadReport_UserInformation::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* ClientDownloadReport_UserInformation::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientDownloadReport

// optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
inline bool ClientDownloadReport::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDownloadReport::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDownloadReport::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDownloadReport::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::safe_browsing::ClientDownloadReport_Reason ClientDownloadReport::reason() const {
  return static_cast< ::safe_browsing::ClientDownloadReport_Reason >(reason_);
}
inline void ClientDownloadReport::set_reason(::safe_browsing::ClientDownloadReport_Reason value) {
  GOOGLE_DCHECK(::safe_browsing::ClientDownloadReport_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// optional .safe_browsing.ClientDownloadRequest download_request = 2;
inline bool ClientDownloadReport::has_download_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDownloadReport::set_has_download_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDownloadReport::clear_has_download_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDownloadReport::clear_download_request() {
  if (download_request_ != NULL) download_request_->::safe_browsing::ClientDownloadRequest::Clear();
  clear_has_download_request();
}
inline const ::safe_browsing::ClientDownloadRequest& ClientDownloadReport::download_request() const {
  return download_request_ != NULL ? *download_request_ : *default_instance_->download_request_;
}
inline ::safe_browsing::ClientDownloadRequest* ClientDownloadReport::mutable_download_request() {
  set_has_download_request();
  if (download_request_ == NULL) download_request_ = new ::safe_browsing::ClientDownloadRequest;
  return download_request_;
}
inline ::safe_browsing::ClientDownloadRequest* ClientDownloadReport::release_download_request() {
  clear_has_download_request();
  ::safe_browsing::ClientDownloadRequest* temp = download_request_;
  download_request_ = NULL;
  return temp;
}

// optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
inline bool ClientDownloadReport::has_user_information() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDownloadReport::set_has_user_information() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDownloadReport::clear_has_user_information() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDownloadReport::clear_user_information() {
  if (user_information_ != NULL) user_information_->::safe_browsing::ClientDownloadReport_UserInformation::Clear();
  clear_has_user_information();
}
inline const ::safe_browsing::ClientDownloadReport_UserInformation& ClientDownloadReport::user_information() const {
  return user_information_ != NULL ? *user_information_ : *default_instance_->user_information_;
}
inline ::safe_browsing::ClientDownloadReport_UserInformation* ClientDownloadReport::mutable_user_information() {
  set_has_user_information();
  if (user_information_ == NULL) user_information_ = new ::safe_browsing::ClientDownloadReport_UserInformation;
  return user_information_;
}
inline ::safe_browsing::ClientDownloadReport_UserInformation* ClientDownloadReport::release_user_information() {
  clear_has_user_information();
  ::safe_browsing::ClientDownloadReport_UserInformation* temp = user_information_;
  user_information_ = NULL;
  return temp;
}

// optional bytes comment = 4;
inline bool ClientDownloadReport::has_comment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientDownloadReport::set_has_comment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientDownloadReport::clear_has_comment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientDownloadReport::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& ClientDownloadReport::comment() const {
  return *comment_;
}
inline void ClientDownloadReport::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ClientDownloadReport::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void ClientDownloadReport::set_comment(const void* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDownloadReport::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* ClientDownloadReport::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .safe_browsing.ClientDownloadResponse download_response = 5;
inline bool ClientDownloadReport::has_download_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientDownloadReport::set_has_download_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientDownloadReport::clear_has_download_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientDownloadReport::clear_download_response() {
  if (download_response_ != NULL) download_response_->::safe_browsing::ClientDownloadResponse::Clear();
  clear_has_download_response();
}
inline const ::safe_browsing::ClientDownloadResponse& ClientDownloadReport::download_response() const {
  return download_response_ != NULL ? *download_response_ : *default_instance_->download_response_;
}
inline ::safe_browsing::ClientDownloadResponse* ClientDownloadReport::mutable_download_response() {
  set_has_download_response();
  if (download_response_ == NULL) download_response_ = new ::safe_browsing::ClientDownloadResponse;
  return download_response_;
}
inline ::safe_browsing::ClientDownloadResponse* ClientDownloadReport::release_download_response() {
  clear_has_download_response();
  ::safe_browsing::ClientDownloadResponse* temp = download_response_;
  download_response_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientUploadResponse

// optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
inline bool ClientUploadResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientUploadResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientUploadResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientUploadResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::safe_browsing::ClientUploadResponse_UploadStatus ClientUploadResponse::status() const {
  return static_cast< ::safe_browsing::ClientUploadResponse_UploadStatus >(status_);
}
inline void ClientUploadResponse::set_status(::safe_browsing::ClientUploadResponse_UploadStatus value) {
  GOOGLE_DCHECK(::safe_browsing::ClientUploadResponse_UploadStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional string permalink = 2;
inline bool ClientUploadResponse::has_permalink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientUploadResponse::set_has_permalink() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientUploadResponse::clear_has_permalink() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientUploadResponse::clear_permalink() {
  if (permalink_ != &::google::protobuf::internal::kEmptyString) {
    permalink_->clear();
  }
  clear_has_permalink();
}
inline const ::std::string& ClientUploadResponse::permalink() const {
  return *permalink_;
}
inline void ClientUploadResponse::set_permalink(const ::std::string& value) {
  set_has_permalink();
  if (permalink_ == &::google::protobuf::internal::kEmptyString) {
    permalink_ = new ::std::string;
  }
  permalink_->assign(value);
}
inline void ClientUploadResponse::set_permalink(const char* value) {
  set_has_permalink();
  if (permalink_ == &::google::protobuf::internal::kEmptyString) {
    permalink_ = new ::std::string;
  }
  permalink_->assign(value);
}
inline void ClientUploadResponse::set_permalink(const char* value, size_t size) {
  set_has_permalink();
  if (permalink_ == &::google::protobuf::internal::kEmptyString) {
    permalink_ = new ::std::string;
  }
  permalink_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientUploadResponse::mutable_permalink() {
  set_has_permalink();
  if (permalink_ == &::google::protobuf::internal::kEmptyString) {
    permalink_ = new ::std::string;
  }
  return permalink_;
}
inline ::std::string* ClientUploadResponse::release_permalink() {
  clear_has_permalink();
  if (permalink_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = permalink_;
    permalink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace safe_browsing

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_csd_2eproto__INCLUDED
